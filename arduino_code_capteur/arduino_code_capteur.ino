
////////////// INCLUSION DES BIBLIOTHEQUES////////////

#include <Adafruit_SSD1306.h>               // Bibliothèque de l'écran OLED
#include <SPI.h>                            // Bibliothèque pour communiquer avec le potentiomètre digital
#include <SoftwareSerial.h>                 // Bibliothèque pour gérer la communication avec l'appareil bluetooth

////////////// DEFINITION VARIABLES ////////////

// Ecran OLED
#define nombreDePixelsEnLargeur 128         // Taille de l'écran OLED, en pixel, au niveau de sa largeur
#define nombreDePixelsEnHauteur 64          // Taille de l'écran OLED, en pixel, au niveau de sa hauteur
#define brocheResetOLED         -1          // Reset de l'OLED partagé avec l'Arduino (d'où la valeur à -1, et non un numéro de pin)
#define adresseI2CecranOLED     0x3C        // Adresse de "mon" écran OLED sur le bus i2c (généralement égal à 0x3C ou 0x3D) 
Adafruit_SSD1306 ecranOLED(nombreDePixelsEnLargeur, nombreDePixelsEnHauteur, &Wire, brocheResetOLED);

// IMAGE ECRAN D'ACCUEIL
const unsigned char imageAccueil [] PROGMEM = {
	// 'BIENVENUE SUR LE PROGRAMME DE LOLA ET ADELE(3), 128x64px
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0xf8, 0xdf, 0x98, 0xd8, 0xdf, 0xb9, 0x99, 0xdf, 0x83, 0xe6, 0x37, 0xe0, 0x61, 0xf8, 0x00, 
	0x00, 0xdc, 0xdf, 0x9c, 0xd9, 0x9f, 0xbd, 0x99, 0xdf, 0x83, 0x76, 0x37, 0xf0, 0x61, 0xf8, 0x00, 
	0x00, 0xcc, 0xdf, 0x9e, 0xdd, 0x9f, 0x3d, 0x99, 0xdf, 0x83, 0xc6, 0x37, 0x30, 0x61, 0xf8, 0x00, 
	0x00, 0xfc, 0xdf, 0x9f, 0xcd, 0x9f, 0x37, 0x99, 0xdf, 0x81, 0xf6, 0x37, 0xe0, 0x61, 0xf8, 0x00, 
	0x00, 0xcc, 0xdc, 0x1b, 0xcf, 0x18, 0x33, 0x99, 0x98, 0x07, 0x37, 0x77, 0x60, 0x61, 0xc0, 0x00, 
	0x00, 0xfc, 0xdf, 0x99, 0xc7, 0x1f, 0xb3, 0x9f, 0x9f, 0x83, 0xe3, 0xe7, 0x70, 0x7f, 0xfc, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 
	0x18, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 
	0x1e, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 
	0x07, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7c, 0xc0, 
	0x03, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xc0, 
	0x03, 0x00, 0x00, 0x00, 0x30, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xc0, 
	0x03, 0x00, 0x7e, 0xfe, 0xfc, 0x7e, 0x7e, 0x3c, 0xf7, 0xb9, 0xcf, 0xc3, 0xf3, 0xf0, 0x01, 0xc0, 
	0x00, 0x00, 0x66, 0xc6, 0xc6, 0xe6, 0x66, 0x3c, 0xf7, 0xbd, 0xcc, 0x03, 0x3b, 0x00, 0x00, 0x80, 
	0x00, 0x00, 0x7e, 0xfc, 0xc6, 0xce, 0x7e, 0x6c, 0xd7, 0xbf, 0xcf, 0x83, 0x1b, 0xf0, 0x00, 0x00, 
	0x00, 0x00, 0x7c, 0xdc, 0xc6, 0xc6, 0x6c, 0x7e, 0xdf, 0xbe, 0xcc, 0x03, 0x3b, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x60, 0xcc, 0xfe, 0x7e, 0x6e, 0xfe, 0xdf, 0xb6, 0xcf, 0xc3, 0xf3, 0xf0, 0x00, 0x00, 
	0x00, 0x00, 0x60, 0xce, 0x38, 0x3a, 0x66, 0xc7, 0xcb, 0xb6, 0xcf, 0xc3, 0xe3, 0xf0, 0x00, 0x00, 
	0x00, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xc3, 0xe0, 
	0x00, 0x1c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xf7, 0x00, 
	0x0c, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x00, 
	0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1c, 0x00, 
	0x00, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 
	0x00, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x30, 0x06, 0x0f, 0xcc, 0x0e, 0x03, 0xf7, 0xe0, 0x78, 0xf9, 0xfd, 0x83, 0xf0, 0x00, 0x0c, 
	0x00, 0x00, 0x06, 0x1c, 0xcc, 0x0f, 0x03, 0x01, 0x80, 0x78, 0xcd, 0xc1, 0x83, 0x00, 0x00, 0x1c, 
	0x00, 0x00, 0x06, 0x18, 0xec, 0x1b, 0x03, 0xe1, 0x80, 0x78, 0xcd, 0xf9, 0x83, 0xe0, 0x18, 0x30, 
	0x00, 0x00, 0x06, 0x18, 0xec, 0x1b, 0x83, 0x01, 0x80, 0xcc, 0xcd, 0xc1, 0x83, 0x00, 0x1f, 0xb0, 
	0x30, 0x00, 0x07, 0xef, 0xcf, 0xff, 0x83, 0xf1, 0x80, 0xfc, 0xfd, 0xfd, 0xfb, 0xf0, 0x01, 0xf0, 
	0x38, 0x00, 0x07, 0xe7, 0x8f, 0xf1, 0x83, 0xf1, 0x81, 0xce, 0xf9, 0xfd, 0xfb, 0xf0, 0x00, 0xf0, 
	0x1c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 
	0x06, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x07, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 
	0x07, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x1f, 0x80, 0x00, 0x06, 0x00, 0x0f, 
	0x07, 0x00, 0x1f, 0x80, 0x03, 0xf8, 0x00, 0x7f, 0x80, 0x00, 0x7f, 0xe0, 0x00, 0x7f, 0xc0, 0x3f, 
	0x02, 0x00, 0xff, 0xe0, 0x07, 0xfe, 0x01, 0xff, 0xe0, 0x01, 0xff, 0xf0, 0x01, 0xff, 0xe0, 0x7f, 
	0xe0, 0x03, 0xff, 0xfc, 0x1f, 0xff, 0x87, 0xff, 0xf0, 0x03, 0xff, 0xfc, 0x0f, 0xff, 0xf0, 0xff, 
	0xf8, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
};

// Module bluetooth
#define rxPin 8 //Broche 8 en tant que RX, a raccorder sur TX du HC-05
#define txPin 7 //Broche 7 en tant que RX, a raccorder sur TX du HC-05
SoftwareSerial Bluetooth(rxPin ,txPin); //Definition du software serial

// Flex Sensor commercial
const int flexPin = A1;
const float VCC = 5.0;                    // Tension de l'arduino
const float R_DIV = 10000.0;              // resistance pour créer le pont diviseur de tension
const float flatResistance = 36000.0;     // resistance quand le flex est à plat
const float bendResistance = 102000.0;    // resistance quand le flex est courbé à 90 degrés
const float kohm = 0.001;                 //convertit la resistance en kohms (simplifie l'affichage)
char buffer_flex[15];
char tabFlex[15];

//Graphite sensor
const int graphPin = A0;
const float R8 = 100000;
const float R4 = 100000;
float R2 = 50000;               //Valeur du potentiomètre digital à l'initialisation
const float R5 = 10000;
const float Mohm = 0.000001;
char buffer[15];
char tabGraphite[15];


// Digital Potentiometer
#define CSpin 10
#define SDIpin 11
#define SCKpin 13
#define MCP_NOP 0b00000000
#define MCP_WRITE 0b00010001
#define MCP_SHTDWN 0b00100001
const byte address = 0x11;
int pos = 0;                                   // pour déterminer R2 (potentiomètre) (0<pos<255) , plus pos -> 0, plus R2 est grand
int lastA = LOW;

// Rotatory Encoder 
#define encoder0pinA 2
#define encoder0pinB 4
#define SWITCHpin 5
volatile unsigned int encoder0Pos = 0;


#define baudrate 9600

void setup() {

  Serial.begin(baudrate);
  Bluetooth.begin(baudrate);

  // Initialisation de l'écran OLED
  if(!ecranOLED.begin(SSD1306_SWITCHCAPVCC, adresseI2CecranOLED)){
    while(1);                                                           // Arrêt du programme (boucle infinie) si échec d'initialisation
  }
  
  ecranOLED.clearDisplay();                                            // Effaçage de l'intégralité du buffer

  ecranOLED.drawBitmap( 0,0,imageAccueil,nombreDePixelsEnLargeur, nombreDePixelsEnHauteur,WHITE);
  ecranOLED.display();
  delay(1000);
  ecranOLED.clearDisplay();

  // Initialisation pins
  pinMode(rxPin,INPUT);
  pinMode(txPin,OUTPUT);
  pinMode(flexPin, INPUT);
  pinMode(CSpin, OUTPUT);
  pinMode(encoder0pinA,INPUT);
  pinMode(encoder0pinB,INPUT);
  // pinMode(SWITCHpin, INPUT);



  //Potentiometer setup
  digitalWrite(CSpin,HIGH); //SPI chip disabled
  SPI.begin();
  int R2 = digitalPotWrite(pos);

  //Encodeur rotatoire setup
  digitalWrite(encoder0pinA, HIGH);
  digitalWrite(encoder0pinB, HIGH);
  attachInterrupt(0,doEncoder,RISING);

}

//////////////Digital Potentiometer///////////////////////////

float digitalPotWrite (int value){

  digitalWrite(CSpin, LOW);
  SPI.transfer(address);
  SPI.transfer(value);
  digitalWrite(CSpin, HIGH);
  float Rdp = (50000.0 * (255 - value)) / 255.0; 
  Serial.println(Rdp);
  return Rdp;
}

///////////////////Measure/////////////////////////////////////////

float flexMeasure() {

  int ADCflex = analogRead(flexPin);                                          // Lit la tension ADC pour calculer la résistance
  float Vflex = ADCflex * VCC / 1024.0;
  float Rflex = (R_DIV * (VCC / Vflex - 1.0))*kohm;
  Serial.println("Resistance : " + String(Rflex) + " kohms");
  float angle = map(Rflex/kohm, flatResistance, bendResistance, 0, 90.0);     // Utilise la résistance calculée pour avoir l'angle
  Serial.println("Bend : " + String(angle) + " degrees");
  Serial.println();
  delay(100);
  return angle;
}

float graphiteMeasure () {

  float V = analogRead(graphPin);
  Serial.println("V =" + String(V));
  float Vadc = V*5.0/1024.0;
  Serial.println("Vadc =" + String(Vadc));
  float Rg = (R8*(1+R4/R2)*(VCC/Vadc)-R8-R5)*kohm;
  Serial.println("Rgraphite ="+ String(Rg) + "kohms");
  delay(200);
  return V;

}

//////////////BLUETOOTH/////////////////////////////

void bluetoothData () {

  float Vgraphite = graphiteMeasure() * 5.0/1024.0;
  float Rg = (R8*(1+R4/R2)*(VCC/Vgraphite)-R8-R5)*kohm;
  float Vflex = analogRead(flexPin) *5.0/1024;
  float Rflex = (R_DIV * (5 / Vflex - 1.0))*kohm;

  dtostrf(Rg, 4, 2, buffer);
  sprintf(tabGraphite, "%s\n", buffer);
  Bluetooth.print(tabGraphite);

  // Serial.println(tabGraphite);
}


/////////////// FONCTIONS DISPLAY MENUS////////////////////
void principalMenu() {

  ecranOLED.clearDisplay();
  ecranOLED.setCursor(0, 0);
  int tailleDeCaractere=1;
  ecranOLED.setTextColor(SSD1306_WHITE, SSD1306_BLACK); // Couleur du texte, et couleur du fond
  ecranOLED.setTextSize(tailleDeCaractere);
  ecranOLED.println("Graphite Sensor");
  ecranOLED.println("Flex Sensor");
  ecranOLED.println("Digital Potentiometer");
  ecranOLED.display();
  
}

void graphiteMenu(float V) {

  ecranOLED.clearDisplay(); // Effaçage de l'intégralité du buffer
  ecranOLED.setCursor(0, 0);

  int tailleDeCaractere=1;
  float Vadc = V*5.0/1024;

  ecranOLED.setTextColor(SSD1306_WHITE, SSD1306_BLACK); // Couleur du texte, et couleur du fond
  ecranOLED.setTextSize(tailleDeCaractere);
  ecranOLED.println("--Menu GraphSensor--");
  ecranOLED.println();
  ecranOLED.print("Tension =");
  ecranOLED.println(Vadc);
  ecranOLED.print("R =");
  ecranOLED.print((R8*(1+R4/R2)*(VCC/Vadc)-R8-R5)*kohm);
  ecranOLED.println(" kOhm");
  ecranOLED.println();
  ecranOLED.print("             BACK");
  ecranOLED.display(); // Transfert le buffer à l'écran
  delay(200);
  ecranOLED.clearDisplay();
  ecranOLED.setCursor(0, 0);
}

void flexMenu(float angle) {

  int ADCflex = analogRead(flexPin);
  float Vflex = ADCflex * VCC / 1023.0;
  int tailleDeCaractere=1;
  
  ecranOLED.clearDisplay();
  ecranOLED.setCursor(0, 0);

  ecranOLED.setTextColor(SSD1306_WHITE, SSD1306_BLACK); // Couleur du texte, et couleur du fond
  ecranOLED.setTextSize(tailleDeCaractere);
  ecranOLED.println(" --Menu FlexSensor--");
  ecranOLED.println();
  ecranOLED.print("R=");
  ecranOLED.println(String((R_DIV * (VCC / Vflex - 1.0))*kohm) +"Kohms");
  ecranOLED.print("Angle =");
  ecranOLED.println(String(angle) + "degrees");
  ecranOLED.println();
  ecranOLED.print("             BACK");

  delay(500);
  ecranOLED.display();
}

void potMenu(float Rdp) {

  ecranOLED.clearDisplay();
  ecranOLED.setCursor(0, 0);
  int tailleDeCaractere = 1;

  ecranOLED.setTextColor(SSD1306_WHITE, SSD1306_BLACK); // Couleur du texte, et couleur du fond
  ecranOLED.setTextSize(tailleDeCaractere);
  ecranOLED.println("-Menu Potentiometre-");
  ecranOLED.println();
  ecranOLED.print("Rdp =");                           //Résistance choisie pour le potentiomètre digital
  ecranOLED.println(String(Rdp)+"ohms");
  ecranOLED.println();
  ecranOLED.println();
  ecranOLED.print("             BACK");

  ecranOLED.display();
  
}
//////////////////////////////////////////////////////////////////////////////

///////////////////////// Encodeur Rotatoire //////////////////////////////////

void doEncoder() {

  int currentA = digitalRead(encoder0pinA);
  if (currentA != lastA && currentA == HIGH) {
    if (digitalRead(encoder0pinB) == LOW) {
      pos++;                                    // sens horaire
    } else {
      pos--;                                    // sens anti-horaire
    }
  }
    // Limites
  if (pos > 255) pos = 255;
  if (pos < 0) pos = 0;
  lastA = currentA;
}

////////////////////////////////////////////////////////////////////////////////

void loop() {

doEncoder();

// graphiteMenu(graphiteMeasure());
// delay(5000);
// flexMenu(flexMeasure());
// delay(5000);
potMenu(digitalPotWrite(pos));
// delay(5000);
// bluetoothData();

}